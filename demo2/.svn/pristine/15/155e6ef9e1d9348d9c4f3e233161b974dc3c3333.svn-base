#include "b.h"

bool others_later(Board* board, Player* player, int curStop);
void first_open(Board* board, int curStop);
bool look_for(Board* board, int curStop, bool (*check)(Stop*));
int next_barrier(Board* board, int curStop);
bool highest_card(Board* board, Player* player, int curStop);

void play_move(Game* game, Player* player) {
    int curStop = player_pos(game->board, player);

    // #1 case in user move choice.
    if (others_later(game->board, player, curStop)) {
        //printf("A\n");
        return;
    }
    // #2 case in user move choice.
    if (player->money %2 != 0 && look_for(game->board, curStop, &valid_money_stop)) {
        //printf(" %d", player->money % 2);
        //printf("B\n");
        return;
    }

    // #3 case in user move choice.
    if (highest_card(game->board, player, curStop)) {
        //printf("C\n");
        return;
    }

    // #4 case in user move choice.
    if (look_for(game->board, curStop, &valid_v2_stop)) {
        //printf("D\n");
        return;
    }


    // #5 case in user move choice.
    first_open(game->board, curStop);
    //printf("E\n");
    return;
}

bool others_later(Board* board, Player* player, int curStop) {
    if (get_stop(board, player, curStop)->numPlaced > 1) {
        //printf("yep fixed");
        return false;
    }

    for (int i = 0; i < curStop; ++i) {
        Stop* stop = &board->stops[i];
        if (stop->numPlaced > 0) {
            //printf("what");
            return false;
        }
    }

    //printf("%s", board->stops[curStop + 1].type);

    if (at_capacity(&board->stops[curStop + 1])) {
        //printf("the");
        return false;
    }
    chosen_move(curStop + 1, stdout);
    return true;
}

bool look_for(Board* board, int curStop, bool (*check)(Stop*)) {
    int nextBarr = next_barrier(board, curStop);
    //printf("next b : %d\n", nextBarr);
    for (int i = curStop + 1; i < nextBarr; ++i) {
        //printf("%d", i);
        Stop* stop = &board->stops[i];
        if (check(stop)) {
            chosen_move(i, stdout);
            return true;
        }
    }
    return false;
}

void first_open(Board* board, int curStop) {
    for (int i = curStop + 1; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        if (!at_capacity(stop)) {
            chosen_move(i, stdout);

            return;
        }
    }
}

int next_barrier(Board* board, int curStop) {
    for (int i = curStop + 1; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        if (strcmp(stop->type, "::") == 0) {
            return i;
        }
    }
    return 0;
}

bool highest_card(Board* board, Player* player, int curStop) {
    for (int i = 0; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        for (int j = 0; j < stop->numPlaced; ++j) {
            if (stop->placed[j].numCards > player->numCards) {
                printf(" WHY: %d %d\n", stop->placed[j].pid, player->pid);
                return false;
            }
        }
    }

    if (look_for(board, curStop, &valid_ri_stop)) {
        return true;
    }

    return false;
}