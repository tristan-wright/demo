#include "board.h"

int contains(Stop* stop, pid_t pid) {
    for (int i = 0; i < stop->numPlaced; ++i) {
        if (stop->placed[i].pid == pid) {
            return i;
        }
    }
    return -1;
}

void add_card(Player* player, int card) {
    if (card == 0) {
        return;
    }
    player->cards = realloc(player->cards, sizeof(int) * (player->numCards + 1));
    player->cards[player->numCards] = card;
    player->numCards++;
}

int count_cards(Player* player, int card) {
    int counter = 0;
    for (int i = 0; i < player->numCards; ++i) {
        if (player->cards[i] == card) {
            counter++;
        }
    }

    return counter;
}

bool add_player(Stop* stop, Player* player) {
    if (stop->cap == stop->numPlaced) {
        return false;
    }

    if (stop->numPlaced < 1) {
        stop->placed[0] = *player;
    } else {
        stop->placed[stop->numPlaced] = *player;
    }

    stop->numPlaced += 1;
    return true;
}

bool remove_player(Stop* stop, Player* player) {
    int pos = contains(stop, player->pid);

    if (pos >= 0) {
        for (int i = pos; i < stop->numPlaced - 1; ++i) {
            stop->placed[i] = stop->placed[i+1];
        }
        stop->numPlaced--;
        return true;
    }

    return false;
}

/**
 * Moved a player from one stop to another.
 * @param from The stop that the player currently sits.
 * @param to The stop to move the player to.
 * @param id The id of the player to be moved.
 * @return True if the player has been moved.
 */
Player* move(Stop* from, Stop* to, Player* player) {
    if (strcmp(to->type, "V1") == 0) {
        player->visited[0] += 1;
    } else if (strcmp(to->type, "V2") == 0) {
        player->visited[1] += 1;
    }
    return (add_player(to, player) && remove_player(from, player))? player : NULL;
}

/**
 * Determines the high numbers of players placed at a
 * single stop on the board.
 * @param board The board information pointer.
 * @return The highest number of players at a single stop.
 */
int highest_placed(Board* board) {
    int high = 0;
    for (int i = 0; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        if (stop->numPlaced > high) {
            high = stop->numPlaced;
        }
    }
    return high;
}
/**
 * Handles the reading and processing of the path information.
 * @param board The board information.
 * @param file The file pointer to read from.
 * @return True if successfully loaded.
 */
bool read_path(Board* board, FILE* file) {
    char* buff = malloc(sizeof(char) * 80);

    if(feof(stdin)) {
        return false;
    }

    fgets(buff, 80, file);
    char* numStops = strtok(buff, ";");
    char* path = strtok(NULL, ";");

    board->numStops = atoi(numStops);
    if (board->numStops < 2) {
        return false;
    }

    int length = strlen(path);
    if (length != board->numStops * 3 + 1) {
        return false;
    }

    board->stops = malloc(sizeof(Stop) * board->numStops);
    for (int i = 0; i < board->numStops * 3; i+=3) {
        Stop* stop = malloc(sizeof(Stop));
        strncpy(stop->type, path + i, 2);

        char* cap = path + i +2;

        if (isdigit(*cap)) {
            stop->cap = atoi(cap);
        } else if (*cap == '-') {
            stop->cap = board->numPlayers;
            stop->isBarrier = true;
        } else {
            printf("4");
            return false;
        }

        stop->placed = malloc(sizeof(Player) * board->numPlayers);
        stop->numPlaced = 0;

        board->stops[i/3] = *stop;
    }

    if (strcmp(board->stops[0].type, "::") != 0 ||
        strcmp(board->stops[board->numStops - 1].type, "::") != 0 ) {
        return false;
    }

    // Place all players at the start.
    for (int j = board->numPlayers - 1; j >= 0; --j) {
        Player* newPlayer = malloc(sizeof(Player));
        newPlayer->pid = j;
        newPlayer->money = 7;
        newPlayer->points = 0;
        newPlayer->visited[0] = 0;
        newPlayer->visited[1] = 0;
        add_player(&board->stops[0], newPlayer);
    }
    return true;
}

/**
 * Prints the current status of the board.
 * @param board The board information.
 * @param file The file stream to output to.
 */
void print_board(Board* board, FILE* output){
    for (int j = 0; j < board->numStops; ++j) {
        Stop *stop = &board->stops[j];

        fprintf(output, "%s ", stop->type);
    }
    fprintf(output, "\n");

    int mostPlaced = highest_placed(board);

    char** location = malloc(sizeof(char*) * board->numStops);
    for (int i = 0; i < board->numStops; ++i) {
        location[i] = malloc(sizeof(char) * board->numPlayers * 3);
        memset(location[i], ' ', board->numStops * 3 - 1);
    }

    for (int k = 0; k < board->numStops; ++k) {
        Stop* stop = &board->stops[k];
        for (int i = 0; i < stop->numPlaced; ++i) {
            location[i][k*3] = stop->placed[i].pid + '0';
        }
    }

    for (int l = 0; l < mostPlaced; ++l) {
        fprintf(output, "%s \n", location[l]);
    }
}

void print_player(Player* player, FILE* output) {

    int cards[5];

    for (int i = 1; i < 6; ++i) {
        cards[i-1] = count_cards(player, i);
    }

    fprintf(output, "Player %d Money=%d V1=%d V2=%d Points=%d, A=%d B=%d C=%d D=%d E=%d\n",
            player->pid, player->money, player->visited[0], player->visited[1],
            player->points, cards[0], cards[1], cards[2], cards[3], cards[4]);
}

Player* get_player(Board* board, pid_t pid) {
    for (int i = 0; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        for (int j = 0; j < stop->numPlaced; ++j) {
            if (stop->placed[j].pid == pid) {
                return &stop->placed[j];
            }
        }
    }
    return NULL;
}

Stop* get_stop(Board* board, pid_t pid) {
    for (int i = 0; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        for (int j = 0; j < stop->numPlaced; ++j) {
            if (stop->placed[j].pid == pid) {
                return stop;
            }
        }
    }
    return NULL;
}

/*// THIS DOEST NOT WORK YET. USE ABOVE.
void player_find(Stop* stop, pid_t pid) {
    for (int j = 0; j < stop->numPlaced; ++j) {
        if (stop->placed[j].pid == pid) {
            return &stop->placed[j];
        }
    }
}

void* get(Board* board, pid_t pid, void (*check)(Stop*, pid_t)) {
    for (int i = 0; i < board->numStops; ++i) {
        Stop* stop = &board->stops[i];
        check(stop, pid);
    }
    return NULL;
}*/

int position(Board* board, int start, char* type) {
    for (int i = start; i < board->numStops; ++i) {
        if (strcmp(board->stops[i].type, type) == 0) {
            return i;
        }
    }
    return 0;
}

int distance(Board* board, Player* player, char* type) {
    return position(board, 0, type) - position(board, 0, get_stop(board, player->pid)->type);
}

void chosen_move(int distance, FILE* output) {
    fprintf(output, "DO%d\n", distance);
}

bool at_capacity(Stop* stop) {
    return (stop->numPlaced == stop->cap)? true : false;
}